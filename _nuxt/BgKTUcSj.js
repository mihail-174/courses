import{z as b,r as f,A as B,B as I,C as O,D as S,E,G as C,H,I as M,m as z,J as R,K,k as $,l as h}from"./4UpA0A4Z.js";const j=t=>t==="defer"||t===!1;function x(...t){var g;const r=typeof t[t.length-1]=="string"?t.pop():void 0;typeof t[0]!="string"&&t.unshift(r);let[e,l,a={}]=t;if(typeof e!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof l!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const s=H(),v=l,u=()=>null,y=()=>s.isHydrating?s.payload.data[e]:s.static.data[e];a.server=a.server??!0,a.default=a.default??u,a.getCachedData=a.getCachedData??y,a.lazy=a.lazy??!1,a.immediate=a.immediate??!0,a.deep=a.deep??b.deep,a.dedupe=a.dedupe??"cancel";const D=()=>a.getCachedData(e,s)!=null;if(!s._asyncData[e]||!a.immediate){(g=s.payload._errors)[e]??(g[e]=null);const c=a.deep?f:B;s._asyncData[e]={data:c(a.getCachedData(e,s)??a.default()),pending:f(!D()),error:I(s.payload._errors,e),status:f("idle")}}const n={...s._asyncData[e]};n.refresh=n.execute=(c={})=>{if(s._asyncDataPromises[e]){if(j(c.dedupe??a.dedupe))return s._asyncDataPromises[e];s._asyncDataPromises[e].cancelled=!0}if((c._initial||s.isHydrating&&c._initial!==!1)&&D())return Promise.resolve(a.getCachedData(e,s));n.pending.value=!0,n.status.value="pending";const d=new Promise((i,o)=>{try{i(v(s))}catch(m){o(m)}}).then(async i=>{if(d.cancelled)return s._asyncDataPromises[e];let o=i;a.transform&&(o=await a.transform(i)),a.pick&&(o=T(o,a.pick)),s.payload.data[e]=o,n.data.value=o,n.error.value=null,n.status.value="success"}).catch(i=>{if(d.cancelled)return s._asyncDataPromises[e];n.error.value=M(i),n.data.value=z(a.default()),n.status.value="error"}).finally(()=>{d.cancelled||(n.pending.value=!1,delete s._asyncDataPromises[e])});return s._asyncDataPromises[e]=d,s._asyncDataPromises[e]},n.clear=()=>N(s,e);const p=()=>n.refresh({_initial:!0}),w=a.server!==!1&&s.payload.serverRendered;{const c=R();if(c&&!c._nuxtOnBeforeMountCbs){c._nuxtOnBeforeMountCbs=[];const o=c._nuxtOnBeforeMountCbs;O(()=>{o.forEach(m=>{m()}),o.splice(0,o.length)}),S(()=>o.splice(0,o.length))}w&&s.isHydrating&&(n.error.value||D())?(n.pending.value=!1,n.status.value=n.error.value?"error":"success"):c&&(s.payload.serverRendered&&s.isHydrating||a.lazy)&&a.immediate?c._nuxtOnBeforeMountCbs.push(p):a.immediate&&p();const d=K();if(a.watch){const o=E(a.watch,()=>n.refresh());d&&C(o)}const i=s.hook("app:data:refresh",async o=>{(!o||o.includes(e))&&await n.refresh()});d&&C(i)}const _=Promise.resolve(s._asyncDataPromises[e]).then(()=>n);return Object.assign(_,n),_}function N(t,r){r in t.payload.data&&(t.payload.data[r]=void 0),r in t.payload._errors&&(t.payload._errors[r]=null),t._asyncData[r]&&(t._asyncData[r].data.value=void 0,t._asyncData[r].error.value=null,t._asyncData[r].pending.value=!1,t._asyncData[r].status.value="idle"),r in t._asyncDataPromises&&(t._asyncDataPromises[r].cancelled=!0,t._asyncDataPromises[r]=void 0)}function T(t,r){const e={};for(const l of r)e[l]=t[l];return e}const P=t=>t.reduce((r,e)=>({...r,[e.id]:e})),F=$("coursesStore",()=>{const t=f(void 0),r=f(void 0),e=f(void 0),l=h(()=>P(t.value||[])),a=h(()=>(e.value||[]).map(u=>{var y;return{...u,color:(y=l.value[u.colorId])==null?void 0:y.code}})),s=h(()=>P(a.value||[])),v=h(()=>(r.value||[]).map(u=>({...u,category:s.value[u.categoryId]})));return{categoryWithColor:a,coursesWithCategory:v,colors:t,courses:r,categories:e,fetchCourses:async()=>{r.value=await $fetch("/api/courses")},fetchCategories:async()=>{e.value=await $fetch("/api/categories")},fetchColors:async()=>{t.value||(t.value=await $fetch("/api/colors"))}}});export{x as a,F as u};
